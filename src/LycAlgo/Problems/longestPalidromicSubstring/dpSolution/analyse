题目大意:寻找字符串最长子串，其中子串必须满足回文条件，如“aba”，“bb”
输入：字符串ｓ
输出：子字符串ｌ
失败之前状态：可以想到二维数组和dp方法，遍历的时候想到对角线置为１，从右下角开始向左上遍历，每次行从对角线向右遍历
失败原因：１二维数组记录最大长度，题目要求返回字符串，（审题不清，未详细考虑输出实例）
　　　　　２状态转移方程混乱.想从右边和下边取最大值，发现行不通，而且还存在ａｂａ和ｂｂ的差异，并且发现
         ａｂ－ａｂａ和ｂａ－ａｂａ并无差异
正答步骤：创建二维数组ｄｐ，正方形数组的边长为ｓ的长度，按照失败步骤便利，数组存储boolean类型．
状态转移方程：dp[i][j]　＝　( s.charAt(i)==s.charAt(j) && (j-i<=2 || palin[i+1][j-1]) ) ? true : false
正答剖析：针对［失败原因１］，每次存储子字符是否满足，而不是长度，并在每次更新最大值
         针对［失败原因２］，使用短路方式过滤．如ｄｄ和　ｄａｄ可以用j-i<=2　过滤掉后面的普通判断方法　
         除此之外使用判断ｉ＋１和ｊ－１缩小字符串范围，因为二维数组存储之前的状态，不必重复求取，加快时间．