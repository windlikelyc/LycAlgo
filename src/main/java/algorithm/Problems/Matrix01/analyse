题目：01矩阵
题目大意：给定由01组成的矩阵，求每个节点离0最近的距离
如： 0 0 0  变为  0 0 0
     0 1 0       0 1 0
     1 1 1       1 2 1
错误答案：
能够想到dp解法，每个节点的最小值是周围一圈最小值+1。
错误分析：
无法想到遍历顺序，因为前一个节点更新的话后续节点会影响前节点，不知道如何回去更新。
而广度优先遍历和深度优先遍历恰好能够解决传统先上后下先左后右的顺序

正答1：广度优先遍历
正答解法：１、复制二维数组，遍历，遇到０的节点入队，非０节点置为无穷大。
        ２、只要队列不空，出队，看一圈节点
                                比出队节点＋１不大。
                                比出队节点＋１还大。
                                    更新该节点的值，该节点入队
        ３、最终结果：所有节点比周围一圈节点不大
正答分析：如果该节点的值被更新了，说明还有可能被再更新一次，入队排到后面等着最后再处理，先把眼前的节点弄完喽。
        如何存储节点指针呢？见技巧总结：用i，j下标
人生感悟：做事情结果比过程更重要。只要结果正确过程必定正确，做事情要有目的性。不要着眼于细节，详见３，如果事无巨细的思考很容易被中间复杂的过程蒙蔽，只要抓过程看结果就好。
技巧总结： Queue<int[]> q = new LinkedList<>()　LinkList形态下的队列，元素为数组
        入队　 q.offer(new int[]{i, j});　
        出队　　q.poll()


正答2：深度优先遍历
正答解法：遍历原数组，如果不为０
                        记录一圈的值＋１为最小值，如果最小值和当前节点不同
                            当前节点置为最小值，ｄｆｓ一圈的值．
　　　　　最终结果：所有节点的值都等于周围一圈的最小值＋１
正答分析：花费了一个上午考虑细节，详见正答２的感悟，还是被纷繁复杂的过程迷惑了。只要把握最终结果正确就好。
