ps：这是一道还没提交就开始写错误总结的问题
题目大意：给定二维数组，右边和下边代表大西洋，左边和上边代表太平洋，数组每个数组代表海拔，其中高海拔可以向低海或平海拔拔流水。求所有能同时流入
太平洋和大西洋的海拔高度。
输入 Pacific ~   ~   ~   ~   ~
          ~  1   2   2   3  (5) *
          ~  3   2   3  (4) (4) *
          ~  2   4  (5)  3   1  *
          ~ (6) (7)  1   4   5  *
          ~ (5)  1   1   2   4  *
             *   *   *   *   * Atlantic
输出：[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]]
问题：１深度优先遍历如何卡住自身，如２２可以无限流动
                               ２２
解决方案：之前想用一个boolean卡住当前节点，ｄｆｓ返回后将该节点释放。这样相当于无限循环
ｄｆｓ的本质是遍历，相当于每个节点跑一遍，所以只要＊能够＊跑到某一个节点，就将其职位ｔｒｕｅ，

正答：1_dfs解法
从左边和上边四个方向轮番ｄｆｓ矩阵，如果能跑到ｄｆｓ函数则ｖｉｓｉｔｅｄ矩阵相应位置置位ｔｒｕｅ
刚开始的话每个点都能跑到．然后找到所有高于自身的节点，反向推所有能够留到本节点的位置．
如果数组越界或者低于本节点或者已ｖｉｓｉｔｅｄ则跳过，否则ｄｆｓ那个方向的节点．
四个方向跑完后统计两者交集即可．
分析：首先不能按照从上到下从左到右的顺序遍历，要从周围向中间逼近．其次回溯法的思想有些混乱，一个ｖｉｓｉｔｅｄ置为ｔｒｕｅ后就没必要释放了
还有就是有点把ｄｆｓ＂神化＂了，以为ｄｆｓ能够寻找到所有水流路径，太理想化了．已本题为例，只要找到一条路径该路径就被“堵死”了，其他的路径即便可以用
这条路径也不行，得找其他路径，这样得出的ｖｉｓｉｔｅｄ矩阵才有效果。

正答：2_bfs解法
